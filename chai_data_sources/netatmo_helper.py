# pylint: disable=line-too-long, missing-module-docstring

# Netatmo requires an OAuth2 setup process. This involves redirecting a new user to an OAuth2 authorization URL
# and waiting for a response generated by Netatmo on a callback URL. If the user granted permission this response
# contains a code that can be used to generate an access token. This access token is what is needed for all
# future interactions with the Netatmo API. This code handles the OAuth2 dance which is only required once.

# be sure to register an app on the main Netatmo account at https://dev.netatmo.com/apps/createanapp

import os
import signal
import uuid
import webbrowser
from dataclasses import dataclass
from http.server import HTTPServer, BaseHTTPRequestHandler
from threading import Thread
from typing import Optional
from urllib.parse import urlparse, parse_qs

import dacite
import requests

from exceptions import DaciteError
from utilities import optional

REQUEST_ID = str(uuid.uuid4()).strip()  # shared id to process a request for a user code
httpd: Optional[HTTPServer] = None  # shared server to be able to shut it down
scope: str = "read_thermostat write_thermostat"  # scope identifying which permissions we desired
shared_id: str = ""  # shared client_id used throughout different requests
shared_secret: str = ""  # shared client_secret used throughout different requests
shared_port: int = 8080  # the server port used to handle responses


@dataclass
class _TokenResult:
    access_token: str
    expires_in: int
    refresh_token: str


def _kill_helper():
    os.kill(os.getpid(), signal.SIGTERM)


class NetatmoHandler(BaseHTTPRequestHandler):
    """ Basic handler to handle a Netatmo OAuth2 response. """
    def _set_error(self, *, message: str):
        encoded_message = message.encode("utf8")
        self.protocol_version = "HTTP/1.1"
        self.send_response(500, message)
        self.send_header("Content-type", "text/plain")
        self.send_header("Content-Length", str(len(encoded_message)))
        self.end_headers()
        self.wfile.write(message.encode("utf8"))

    def do_GET(self):  # noqa, pylint: disable=invalid-name
        """ Handle a GET request sent to this server. """
        query_components = parse_qs(urlparse(self.path).query)
        query_components = {key: next(iter(value), None) for key, value in query_components.items()}

        # verify that the request_id matches
        state = optional(query_components, "state", "")
        if optional(query_components, "state", "").strip() != REQUEST_ID:
            self._set_error(message=f"invalid state {state} that does not match the request ID {REQUEST_ID} - aborting")
            _kill_helper()
            return

        # check for any errors
        if "error" in query_components:
            error = query_components["error"]
            if error == "invalid_client":
                self._set_error(message="the 'client_id' is not valid; you need to register the client through Netatmo")
            elif error == "access_denied":
                self._set_error(message="the user declined the request for authorisation")
            elif error == "access_denied":
                self._set_error(message=f"programming error: the scope '{scope}' that was provided is invalid")
            else:
                self._set_error(message=f"the Netatmo OAuth2 endpoint returned an unexpected error: {error}")
            _kill_helper()
            return

        # we can handle the code as everything looks to be right
        code = query_components["code"]
        print(f"received the authorisation code: {code}")
        message = "successfully received the authorization code"
        self.protocol_version = "HTTP/1.1"
        self.send_response(200)
        self.send_header("Content-type", "text/plain")
        self.send_header("Content-Length", str(len(message)))
        self.end_headers()
        self.wfile.write(message.encode("utf8"))

        handle_code(code)


def launch_server(address="localhost", *, port=8080, server_class=HTTPServer, handler_class=NetatmoHandler):
    """
    Create a server at the given address and port, to act as a given type of server with a given handler.
    :param address: The address where the server should be.
    :param port: The port to which the server should listen.
    :param server_class: The server class of this particular server.
    :param handler_class: The handler that will deal with any resource requests.
    """
    global httpd  # pylint: disable=global-statement,invalid-name
    httpd = server_class((address, port), handler_class)
    httpd.serve_forever()


def handle_code(code: str):
    """ Take an OAuth2 code retrieved from the Netatmo server and turn it into a refresh key. """
    print("handling the received authorization code")

    payload = {
        "grant_type": "authorization_code",
        "client_id": shared_id,
        "client_secret": shared_secret,
        "code": code,
        "scope": scope,
        "redirect_uri": f"http://localhost:{shared_port}",
    }

    print(f"sending the token request with payload: {payload}")
    result = requests.post("https://api.netatmo.com/oauth2/token", data=payload)
    print(result.text)
    result.raise_for_status()  # check for a valid response
    print("received the response")
    json_data = result.json()

    try:
        data = dacite.from_dict(data_class=_TokenResult, data=json_data)
        print(data)
    except DaciteError as exc:
        print(f"unable to understand the response: {exc}")

    _kill_helper()


def get_api_token(client_id: str, client_secret: str, port: int = 8080, oauth: str = "https://api.netatmo.com/oauth2/"):
    """ Request an OAuth2 authentication process and perform all the handshaking steps to obtain a refresh token. """
    global shared_id, shared_secret, shared_port  # pylint: disable=invalid-name,global-statement

    shared_id = client_id
    shared_secret = client_secret
    shared_port = port

    # prepare the OAuth2 request
    params = {
        "client_id": client_id,
        "redirect_uri": f"http://localhost:{port}",
        "scope": scope,
        "state": REQUEST_ID,
    }
    param_values = [f"{key}={value}" for key, value in params.items()]
    target = f"{oauth}authorize?{'&'.join(param_values)}"

    # launch a minimal server to handle the response
    server_thread = Thread(target=launch_server, kwargs={"port": port})
    server_thread.start()

    print(f"opening request to {target}")
    webbrowser.open(target, new=2)


if __name__ == "__main__":
    get_api_token(client_id="5a339be00d0e23c02e8b65d5", client_secret="eQdExiY8mdk6WNa2UJ44PdLL6")
